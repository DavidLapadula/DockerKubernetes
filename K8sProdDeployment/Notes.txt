- Need to first create a kubernetes cluster, and can make any number of nodes with specific CPU and memory size of VM
- One travis (config file) for each container, so when its pushed CI system updates cluster
    - Before install sign into gcloud sdk, install kubectl, and give user credentials to login properly
    - Need service account to allow the permissions on the service account
- Alpine version of image not the best if the dependencies are required to build the container
- Use volume for encrypted file so container knows about sensitive information like authentication
- Travis CI on local VM to encrypt the file and associated to repo, which is what Travis will use to deploy
    - And then encrypted command in travis.yaml file for before_install to ensure credentials there are getting used
    - Will make encrypted version which is where credentias live, volumed folder means if made in VM will reflect in local machine
    - After Travis unencrypts it, it will place the file inside of the directory so it can be referenced
- Need to set project, compute zone, and cluster
    - Cluster needed so Google cloud can reach out and work specifically with one cluster
- Script to build image, tag image, and push to docker (do this all in custom bash file)
- kubectl to set image on an object to ensure that it updates
    - Implicit latest tag will prevent deployment from using latest image because it will think there has yet to be a change
    - Every commit generates unique SHA, so use this to tag the image and will always be new
    - This also helps for debugging so can revert to that commit and codebase will reflect current state of code
        - Still use latest tag so it can still be referenced by latest if it has to be rebuilt/recloned 
    - env stored in yaml file for git commit unique id
    - Need to push for each image tag, :latest default and SHA
- Helm for 3rd party service inside of cluster (like nginx deployment inside)
- 
    